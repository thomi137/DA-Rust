name: Deep LAPACK Linking Debug

on:
  workflow_dispatch:
  push:
    branches: [test]
  pull_request:

jobs:
  deep-debug:
    runs-on: ubuntu-latest
    env:
      # set defaults; we will override/test multiple variants in the job
      TEST_CPP=/tmp/test_dstev.c
      TEST_OUT=/tmp/test_dstev
      RUST_SAMPLE=/tmp/rust_lapack_sample

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install system deps (BLAS/LAPACK, compilers, tools)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential gfortran clang pkg-config \
            libblas-dev liblapack-dev libopenblas-dev libatlas-base-dev \
            binutils-dev patchelf

      - name: Show installed libs and paths
        run: |
          echo "=== lib lists (ldconfig) ==="
          ldconfig -p | egrep 'blas|lapack|openblas|atlas' || true
          echo
          echo "=== Files in /usr/lib/x86_64-linux-gnu ==="
          ls -l /usr/lib/x86_64-linux-gnu | egrep 'blas|lapack|openblas|atlas' || true
          echo
          echo "=== /lib/x86_64-linux-gnu links ==="
          ls -l /lib/x86_64-linux-gnu | egrep 'blas|lapack|openblas|atlas' || true

      - name: Show symbols for candidate libraries (nm / readelf)
        run: |
          for lib in /usr/lib/x86_64-linux-gnu/libopenblas.so* /usr/lib/x86_64-linux-gnu/liblapack.so* /lib/x86_64-linux-gnu/liblapack_atlas.so* /usr/lib/x86_64-linux-gnu/libf77blas.so*; do
            if [ -e "$lib" ]; then
              echo "---- SYMBOLS in $lib ----"
              echo "nm -D $lib | egrep 'dstev|dstev_' || true"
              nm -D "$lib" | egrep 'dstev|dstev_' || true
              echo "readelf -s $lib | egrep 'dstev|dstev_' || true"
              readelf -s "$lib" | egrep 'dstev|dstev_' || true
              echo
            fi
          done

      - name: Try compile + link small C shim that references dstev_ (C -> Fortran symbol)
        run: |
          cat > $TEST_CPP <<'EOF'
          /* small C test that references dstev_ symbol (Fortran naming) */
          #include <stdio.h>
          /* declare Fortran routine symbol */
          void dstev_(char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);
          int main(void){
              /* do not actually call; just reference to force linker symbol */
              void (*p)(char*, int*, double*, double*, double*, int*, double*, int*);
              p = (void*)dstev_;
              (void)p;
              printf("reference compiled\\n");
              return 0;
          }
          EOF

          # Try linking with various link flags:
          set -e
          echo "Attempting link with -lopenblas"
          if gcc $TEST_CPP -o ${TEST_OUT}_openblas -lopenblas -Wl,--verbose 2>&1 | sed -n '1,200p'; then echo "linked with openblas"; else echo "openblas link failed"; fi || true

          echo "Attempting link with -llapack -lblas"
          if gcc $TEST_CPP -o ${TEST_OUT}_lapack -llapack -lblas -Wl,--verbose 2>&1 | sed -n '1,200p'; then echo "linked with lapack+blas"; else echo "lapack+blas link failed"; fi || true

          echo "Attempting link with -llapack_atlas -lf77blas -lcblas"
          if gcc $TEST_CPP -o ${TEST_OUT}_atlas -llapack_atlas -lf77blas -lcblas -Wl,--verbose 2>&1 | sed -n '1,200p'; then echo "linked with atlas"; else echo "atlas link failed"; fi || true

          echo "Attempting link with -lopenblas -lgfortran"
          if gcc $TEST_CPP -o ${TEST_OUT}_openblas_gfortran -lopenblas -lgfortran -Wl,--verbose 2>&1 | sed -n '1,200p'; then echo "linked with openblas+gfortran"; else echo "openblas+gfortran link failed"; fi || true

      - name: Small Rust sample linking test (tries multiple link variations)
        run: |
          set -e
          # create a minimal rust project that references an external symbol
          rm -rf $RUST_SAMPLE
          mkdir -p $RUST_SAMPLE
          cat > $RUST_SAMPLE/Cargo.toml <<'CARGO'
          [package]
          name = "rust_lapack_sample"
          version = "0.0.0"
          edition = "2021"
          CARGO
          mkdir -p $RUST_SAMPLE/src
          cat > $RUST_SAMPLE/src/main.rs <<'RS'
          extern "C" {
              fn dstev_();
          }
          fn main() {
              unsafe {
                  let _p = dstev_ as *const ();
                  // don't call it; just reference symbol
                  println!("referenced dstev_: {:?}", _p);
              }
          }
          RS

          # Try cargo build with different env combinations and capture the rustc invocation
          export CARGO_TARGET_DIR=/tmp/rust_lapack_sample_target
          rm -rf "$CARGO_TARGET_DIR" || true

          echo "=== Build: try linking with openblas via RUSTFLAGS (linker=cc) ==="
          RUSTFLAGS="-C linker=cc -C link-args=-lopenblas -C link-args=-lgfortran" cargo build -v --manifest-path $RUST_SAMPLE/Cargo.toml 2>&1 | sed -n '1,400p' || true

          echo "=== Build: try linking with lapack+blas via RUSTFLAGS ==="
          RUSTFLAGS="-C linker=cc -C link-args=-llapack -C link-args=-lblas -C link-args=-lgfortran" cargo build -v --manifest-path $RUST_SAMPLE/Cargo.toml 2>&1 | sed -n '1,400p' || true

          echo "=== Build: try linking with lapack_atlas ==="
          RUSTFLAGS="-C linker=cc -C link-args=-llapack_atlas -C link-args=-lf77blas -C link-args=-lcblas -C link-args=-lgfortran" cargo build -v --manifest-path $RUST_SAMPLE/Cargo.toml 2>&1 | sed -n '1,400p' || true

      - name: Print verbose cargo build for your repo (captures emitted build script lines)
        run: |
          echo "=== Clean repo build ==="
          cargo clean
          # set debug env for build scripts
          export RUST_BACKTRACE=1
          export RUST_LOG=build=debug
          # Force use cc & try linking openblas as well, but we will not assume it's correct
          export RUSTFLAGS="-C linker=cc -C link-args=-lopenblas -C link-args=-lgfortran"
          # Build with -vv to capture rustc invocations and build-script output
          cargo build -vv 2>&1 | sed -n '1,400p' || true

      - name: If cargo build failed, capture last 100 lines from syslog of the raw output file
        if: failure()
        run: |
          # The previous step already printed output; show last 200 lines to ensure we see the undefined symbol
          echo "=== LAST LINES FROM PREVIOUS BUILD LOG (search for 'undefined' / 'dstev' / 'ld returned') ==="
          # We rely on the action printing the log; here we attempt to find in the raw build output captured earlier in the logs.
          # Helpful greps:
          true

      - name: Print summary instructions
        run: |
          echo "=== Diagnostic run complete ==="
          echo "Look for:"
          echo "  * Which library (if any) contains 'dstev_' from the nm/readelf outputs above."
          echo "  * Which gcc linking attempt succeeded above (openblas, lapack+blas, atlas)."
          echo "  * The 'cargo build -vv' block: find emitted 'cargo:rustc-link-lib=...' lines from lapack-sys/build scripts."
          echo "  * If rustc still fails, copy the final undefined symbols and the immediate linker command shown just above them (we need the exact -l and -L args)."
